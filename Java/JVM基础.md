# JVM 基础

## 运行时数据区

JVM 在程序执行时定义了多个运行时数据区，有些数据区是由 JVM 在启动时创建并且在 JVM 退出后摧毁的，有些数据区是由每个线程所有的。每个线程私有的数据区在由线程创建时创建，随着线程的退出而销毁。

主要存在以下几个运行时数据区：由线程共享的运行时数据区：堆区、方法区；线程私有的运行时数据区：虚拟机栈、本地方法栈、程序计数器



### 程序计数器

> JVM 可以支持多条线程同时执行，每一个 Java 虚拟机线程都有自己的一个 程序计数器。在任意时刻，每个 Java 虚拟机线程只会执行一个方法的代码，这个正在被执行的方法称为该线程的当前方法。如果当前执行的方法不是 native 的，那么这个程序计数器就会保存当前被 Java 虚拟机执行的字节码的指令的地址。如果该方法是 native 的，那么程序计数器保存的值将是 undefined。程序计数器的容量应当能够至少保存一个 returnAddress 类型的数据或者一个与平台相关的本地指针的值。



### 虚拟机栈

> 每个 Java 虚拟机线程都有自己的私有 Java 虚拟机栈，这个栈与线程同时创建，用于存储栈帧。Java 虚拟机栈的作用与传统语言（例如 C）中的栈十分类似，用于存储局部变量和一些尚未计算好的结果。另外，它在方法调用和返回中也扮演了很重要的角色。因为除了栈帧的出栈和入栈之外，Java 虚拟机栈不会再受其他的因素影响，所以栈帧可以在堆中分配。Java 虚拟机栈所使用的内存不需要保证是连续的。
>
> ​	Java 虚拟机规范既允许 Java 虚拟机栈被实现成固定大小，也允许根据计算动态地扩展和收缩。如果采用固定大小的 Java 虚拟机栈，那么每一个线程的 Java 虚拟机栈容量可以在线程创建的时候独立选定。
>
> ​	Java 虚拟机实现应当提供给程序员或者最终用户调节虚拟机栈初始容量的手段，对于可以动态扩展和收缩的 Java 虚拟机栈来说，则应当提供调节其最大、最小容量的手段。
>
> ​	Java 虚拟机栈可能会发生如下异常：
>
> - 如果线程请求分配的栈容量超过 Java 虚拟机栈允许的最大容量，Java 虚拟机会抛出一个 `StackOverflowError` 的异常
> - 如果一个 Java 虚拟机栈可以动态扩展，并且尝试扩展的时候无法申请到足够的内存，或者在创建新的线程的时候没有足够的内存去创建对应的 Java 虚拟机栈，那么 Java 虚拟机将会抛出一个 `OutOfMemoryError` 异常

栈中存储的内容：

1. 方法本身是操作码的一部分，保存在虚拟机栈中
2. 方法内部变量（局部变量）作为指令的操作数部分，跟在指令的操作码之后，保存在 `Stack` 中。实际上，对于基本数据类型（byte、char、int、long等）保存在 `Stack` 中；对于对象类型来讲，将会在 `Stack` 中保存对象的引用，而实际对象则保存在**堆区**中
3. 虚拟机栈随着线程的创建而创建，它的生命周期是随着线程的生命周期，线程结束栈内存也就随之释放，因此对于虚拟机栈来讲不存在垃圾回收
4. 局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、int、long）、对象的引用和 returnAddress（指向下一条字节码指令的地址）。局部变量表所需的内存空间在编译器完成分配，在方法运行前，该局部变量表所需要的内存空间是固定的，运行期间也不会发生改变



### 堆区

> 在 Java 虚拟机中，堆是可供各个线程共享的运行时数据区，也是供所有**类实例**和**数组对象**分配内存的区域
>
> Java 堆在虚拟机启动的时候就被创建，它存储了被自动内存管理系统（automatic storage management system），也就是常说的 garbage collector（垃圾收集器）所管理的各种对象，这些受管理的对象无需也无法无法显式地销毁。Java 虚拟机并未假设采用何种具体的技术去实现自动内存管理系统，虚拟机的实现者可以根据系统的实际需要来选择自动内存管理工具。Java 堆的容量可以是固定的，也可以随着程序执行的需求动态地扩展，并在不需要过多空间时自动收缩。Java 堆所使用的内存不需要保证是连续的
>
> Java 虚拟机的实现应当提供给程序员或者用户最终调节 Java 堆初始容量的手段，对于可以动态扩展和收缩的 Java 堆来说，则应当提供调节其最大、最小容量的手段
>
> Java 堆可能会发生以下异常：
>
> - 如果实际所需的堆超过了自动内存管理系统能够提供的最大容量，那么 Java 虚拟机将会抛出一个 `OutOfMemoryError` 异常



### 方法区

> 在 Java 虚拟机中，方法区是提供可供各个线程共享的运行时内存区域。方法区与传统语言中的编译代码存储区或者操作系统进程的正文段的作用非常相似，它存储了每一个类的结构信息，例如，运行时常量池、字段和方法数据、构造函数和普通方法的一些内容，还包括一些在类、实例、接口初始化用到的特殊方法
>
> 方法区在虚拟机启动的时候创建，虽然方法区是堆的逻辑组成的一部分，但是简单的虚拟机实现可以选择在这个区域不实现垃圾收集与压缩。方法区的容量可以是固定的，也可以随着程序执行的需求动态扩展，并在不需要过多空间时自动收缩。方法区在实际内存空间中可以是不连续的
>
> Java 虚拟机实现应当提供给程序员或者最终用户调节方法区初始容量的手段，对于可以动态扩展和收缩的方法区来说，则应当调节其最大、最小容量的手段。
>
> 方法区可能发生的异常情况：
>
> - 如果方法区的内存空间不能满足内存分配请求，那么 Java 虚拟机将会抛出一个 `OutOfMemoryError`异常



### 运行时常量池

> 运行时常量池是 .class 文件中每一个类或接口的常量池表的运行时表示形式，它包括了若干种不同的常量，从编译期已知的数值字面量到必须在运行期解析后才能获取的方法或者字段引用。运行时常量池类似于传统语言中的符号表，不过它存储的数据的范围比通常意义上的符号表要更为广泛。
>
> 每一个运行时常量池都在 Java 虚拟机的方法区中分配，在加载类和接口到虚拟机之后，就会创建对应的运行时常量池
>
> 在创建类和接口的运行时常量池时，可能会发生如下异常情况：
>
> - 当创建类或者接口时，如果构造的运行时常量池所需要的内存空间超过了方法区能够提供的最大值，那么 Java 虚拟机将会抛出一个 `OutOfMemoryError` 异常

运行时常量池位于方法区内部，主要存储编译期产生的字面量和符号引用，运行时产生的新常量可以放入常量池中，如 `String` 的 `intern()` 方法产生的常量

常量池是这个类会用到的常量的一个有序集合，包括直接常量（基本类型，`String`）和其它对类、方法、字段的引用。



### 本地方法栈

> Java 虚拟机的实现可能会使用到传统的栈（通常称为 C Stack）来支持 native 方法（指使用 Java 以外的其它语言编写的方法）执行，这个栈就被称为本地方法栈。当 Java 虚拟机使用其他语言来实现指令集解释器时，也可以使用本地方法栈。如果 Java 虚拟机不支持 native 方法，或者本身不依赖于传统栈，那么可以不提供本地方法栈，如果支持本地方法栈，那么这个栈一般会在线程创建的时候按照线程分配
>
> Java 虚拟机实现应当提供给程序员或者最终用户调节本地方法栈初始容量的手段，对于长度可动态变化的本地方法栈来说，则应当提供调节其最大、最小容量的手段
>
> 本地方法栈可能发生如下异常情况：
>
> - 如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java 虚拟机将会抛出一个 `StackOverflowError` 异常
> - 如果本地方法栈可以动态扩展，并且尝试在扩展的时候无法申请到足够的内存，或者在创建新的线程的时候没有足够的内存去创建对应的本地方法栈，那么虚拟机将会抛出一个 `OutOfMemoryError`异常



## 对象分配

## 类加载机制