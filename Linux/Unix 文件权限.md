# Unix 文件权限

## 简介

在 Unix 或者类 Unix 文件系统中，每个文件（或者目录，目录也被视为文件）都有自己的所属对象和一个与之相关的 Unix 用户组关联，可以通过设置对应的文件的权限标记指定对于所属用户、所属组以及其他用户的、读、写和可执行权限。如果通过组的方式对文件权限进行修改，那么将会使得当前组内的所有用户都具有对应的文件权限；如果是通过其它用户进行文件的权限修改，那么这个修改后的权限对于所有的登录用户都会具有对应的权限

通过 `ls -l` 命令可以查看当前目录下具有的文件信息：

![2022-03-22 08-54-38 的屏幕截图.png](https://s2.loli.net/2022/03/22/NxFfZt46DICXKpo.png)

## 权限结构

从总体上看，权限结构的第一位表示文件的类型，‘-’ 表示一般文件，‘d’ 则表示这是一个目录文件等，具体如下所示：

![file-type-bit.png](https://s2.loli.net/2022/03/22/yYE8d1u9jtzqQkl.png)

总共存在十个比特位，除了第一个比特位之外，后面的 $9$ 个比特位每三个一组，分别组成不同用户的访问权限，具体结构如下图所示：

![File-Permission.png](https://s2.loli.net/2022/03/22/1Fq3CtmWzpdDQ9N.png)

每个组中的权限位描述如下：

- 第一个位为 ‘r’，表示当前的权限组对于当前的文件具有读取权限，如果不存在读取权限，则当前位为 ‘-’
- 第二个位为 ‘w’，表示当前的权限组对于当前的文件具有写入权限，如果不存在写入权限，则当前位为 ‘-’
- 第三个位为 ‘x’，表示当前的权限组对于当前的文件具有执行权限，如果不存在执行权限，则当前位为 ‘-’

如上图所述，此时的文件对于所属用户来讲具备读写权限、对于所属组来讲具备读、写权限，对于其他用户来讲只具备读取权限

由于每个所属位都是一个二进制位，因此实际上每个组的权限可以通过一个八进制的数字来表示，如下表所示：

| 权限 | 二进制值 | 八机制值 |           描述           |
| :--: | :------: | :------: | :----------------------: |
| ---  |   000    |    0     |       没有任何权限       |
| --x  |   001    |    1     |       只有执行权限       |
| -w-  |   010    |    2     |       只有写入权限       |
| -wx  |   011    |    3     |    具备写入和执行权限    |
| r--  |   100    |    4     |       只有读取权限       |
| r-x  |   101    |    5     |    具备读取和写入权限    |
| rw-  |   110    |    6     |    具备读取和写入权限    |
| rwx  |   111    |    7     | 具备读取、写入和执行权限 |

因此有时见到使用 `chmod` 修改文件权限时，通过 ‘777’ 的选项来将所有的权限赋给权限组，使得当前文件对所有用户来讲都具备读取、写入和执行权限，这实际上不是一种很好的方式

## 修改文件权限

### umask

在 Unix 文件系统中，一般文件的默认权限都是 ‘666’（目录文件为 ‘777’），即每个用户都对文件具备读写的权限，但是在创建文件时，需要将该权限减去 umask 对应的值，最终得到的值就是当前文件对应的权限。

在我的系统上，通过 umask 得到的值为 ‘0002’（第一个位为粘着位，在此不做分析），因此当我创建文件时，会将默认的文件权限 ‘666’ 减去 mask 码 ‘002’，为 ‘664’，因此我创建的文件应当是对当前用户以及所属组具有读写权限，而对其它用户则只具备读取权限

umask 的值一般位于 `/etc/profile` 文件中，在我的 Ubuntu 上，它位于 `/etc/login.defs` 文件中，但是一般可以直接通过 `umask` 命令修改这个默认值，如下所示：

```bash
# 修改默认的 umask 值
umask 022
```



### chmod

修改文件权限最常用的命令就是 `chmod`，具体的使用方式如下所示：

chmod *[options]* mode file

其中，`mode` 表示我们修改后的文件权限，如果是通过八进制的方式进行设置的，那么会直接按照上面表格中的权限进行文件的权限修改，比如说，你希望给当前文件加上读写和可执行权限，但是不想其它的用户具有可执行权限，可以执行如下的命令：

```bash
# 现在 file.txt 文件的权限结构就变成了 -rwxrw---
chmod 760 file.txt
```

但是如果使用一般的符号模式进行修改，那么就会复杂一些。

<br />

使用符号模式的一般格式如下所示：

[ugoa...] [+-=] [rwxXstugo.....]

首先，第一个位置的字符定义了权限所属作用的对象，如下所示：

- ‘u’ 表示给当前的所属用户进行进行权限修改
- ‘g’ 表示给当前文件所属组的权限进行修改
- ‘o’ 代表其他用户
- ‘a’ 代表所有用户

第二个位置表示希望给当前的文件执行的操作，‘+’ 表示给文件加上对应的权限，‘-’ 表示将文件具有的权限进行移除，‘=’ 表示将权限设置为后面的值

最后一个位置的符号代表作用到设置上的权限，，除了 `rws` 之外， 主要有以下几个额外的选项：

- ‘X’：如果对象是目录或者它已经具有执行权限，则赋予执行权限
- ‘s’：运行时重新设置 UID 或者 GID
- ‘t’：保留文件或者目录
- ‘u’：设置属主权限
- ‘g’：设置属组权限
- ‘o’：设置其他用户权限

例如，如果希望给其他用户为文件添加该文件的可执行文件：

```bash
chmod o+x file.txt
```

### chown

chown（change file owner and group）改变文件所属者和所属组。而一般来讲，`chown` 用于修改文件所属者，而通过 `chgrp` 改变文件默认的所属组

`chown` 命令的格式如下所示：

chown *options* owner[group] file

可以通过登录名或者 UID 来指定文件的新属主，例如，如果你希望将文件的所属主修改为 ‘tom’，可以执行如下的命令：

```bash
chown tom a.txt
```

这项操作可能需要 `sudo` ：）

**注意：**只有 root 用户能够修改文件的属主。任何属主都能够修改文件的属组，前提是该属主必须是原属组和目标属组的成员

当然，`chown` 也可以同时修改文件所属者和所属组，例如：

```bash
# 将 1.txt 的所属组修改为 dev，将所属用户修改为 jack
chown jack.dev 1.txt

# 单纯地修改该文件的所属组为 dev
chown .dev 1.txt

# 将1.txt 的所属用户修改为 jack，将所属组修改为 jack 的所属组
chown jack. 1.txt
```

`chgrp` 可以更加直观地修改文件的属主，如下所示：

```bash
# 修改 1.txt 的属组为 master
chgrp master 1.txt
```

该操作可能也需要 `sudo`

## 特殊文件权限

上文的 umask 命令中实际上存在四个位，但是我们只是讨论了后三位，在此讨论特殊文件权限

在 Linux 上，为每个文件和目录权限提供了 $3$ 个额外的权限位置：

- setuid （SUID）：当文件被用户使用时，程序会以用户属主的权限运行
- setgid（SGID）：对于文件来说，程序会以文件属组的权限运行；对于目录来讲，目录中创建的新文件会以目录的默认属组作为默认属组
- 粘着位（Sticky Bit）：进程结束后文件还驻留在内存中

同样的，这三个额外的 bit 位也可以以八进制的形式进行设置，具体对应关系如下表所示：

| 二进制值 | 八进制值 |        描述         |
| :------: | :------: | :-----------------: |
|   000    |    0     |    所有位都清零     |
|   001    |    1     |       粘着位        |
|   010    |    2     |       SGID 位       |
|   011    |    3     |    SGID 和粘着位    |
|   100    |    4     |       SUID 位       |
|   101    |    5     |    SUID 和粘着位    |
|   110    |    6     |   SUID 和 SGID 位   |
|   111    |    7     | SUID、SGID 和粘着位 |

如果希望为某个文件添加额外的比特位，只需要将额外的比特位放到原先的一般权限的八进制组前即可，例如，如果希望给 ‘1.txt’ 文件只添加 setuid 特殊权限位，可以执行如下的 `chmod` 命令

```bash
chmod 4644 1.txt
```

由于涉及到权限相关的操作，因此可能需要 `sudo` ：）

如果习惯于使用符号表示的权限来设置特殊权限位，可以使用如下的方式进行操作：

```bash
# 给 1.txt 文件加上 setuid 权限位
chmod u+s 1.txt

# 给 1.txt 文件加上 setgid 权限位
chmod g+s 1.txt

# 给 1.txt 文件加上 sticky 粘着位
chmod +t 1.txt
```

这些操作同样需要 `sudo`

### 实际使用

- 普通用户对于密码的修改

    在 Linux 中，许多的文件都用到了特殊权限位，比如，修改用户的密码需要将密码写入到存储密码的文件中，但是存储用户密码的文件 `/etc/passwd` 只对于 `root` 用户是可写的，因此如果没有超级用户权限的话，用户就无法修改自身的密码。为了解决这个问题，`/user/bin/passwd` 具备 `root` 用户的 `setuid` 位，当普通用户通过 `/usr/bin/passwd` 修改密码时，会具备 `root` 的权限，使得密码的修改操作对于普通用户来讲也能够进行

    ![2022-03-22 20-48-50 的屏幕截图.png](https://s2.loli.net/2022/03/22/MW6yTbgP1sJjxL9.png)

- `/tmp` 目录

    为了防止无意的删除，`/tmp` 目录具备 “粘着位” 的特殊权限，由于带有粘着位的文件会使得进程结束之后文件依旧驻留在内存中，因此除了文件的属主（或者 `root` 用户）之外无法删除这些带有粘着位的文件，由于 `/tmp` 目录本身自带粘着位，因此即使使用 `/tmp` 目录的进程结束了，依旧无法随意删除 `/tmp` 目录中不属于当前用户或当前用户组的文件



<br />

参考：

<sup>[1]</sup> 《Linux 命令行与 Shell 脚本编程大全》

<sup>[2]</sup> https://www.redhat.com/sysadmin/suid-sgid-sticky-bit

<sup>[3]</sup> https://docs.oracle.com/cd/E19253-01/819-7061/secfile-69/index.html