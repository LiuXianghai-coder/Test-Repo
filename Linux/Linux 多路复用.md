# Linux 多路复用（多路转接）

## 出现原因

如果需要从一个文件描述符中读取数据，然后将数据写入到另一个文件描述符时，可以按照如下的阻塞 IO ：

```c
while ((n = read(STDIN_FILENO, buf, BUFFER_SIZE)) > 0) {
    if (write(STDOUT, buf, n) != n) {
        fprintf(stderr, "write error");
    }
}
```

这种方式在只有一个读 `fd` 和一个写 `fd` 的情况下，这种方式能够正常工作，不会有什么问题。但是如果存在多个文件描述符需要被读取，那么在这种情况下，如果一直阻塞等待某个文件描述符读取完成，那么剩下的待读取文件描述符即使能够被读取，也会一直等待。为了解决这个问题，引入多路复用（多路转接）技术来进行处理

假设现在让我们自己设计 `telnet` ，在这里我们主要考虑一下 `telnet` 和远程主机之间的通信问题：`telnet` 从终端（标准输入）中读取输入，将读取到的输入数据写入到网络连接（`fd`）上，同时从网络连接中读取数据，将读取到的数据写回到终端上；在网络连接的另一端，`telneted` 守护进程读取用户输入的命令，并将其返回到终端，具体情况如下图所示：

![telnet.png](https://s2.loli.net/2022/03/24/yB8NYRgHSkszopm.png)

由于 `telnet` 有两个输入，因此传统的阻塞读的方式是不可取的，因为无法知道什么时候读取哪个输入。

如果没有多路复用技术，那么可以考虑以下几种方式解决这个问题：

- 将一个进程通过 `fork`，变成两个进程

    由于变成了两个子进程，可以单独地对每个输入执行阻塞读的操作。但是这样又会产生新的问题：如果 `telnet` 断开了连接，那么需要将对应的进程关闭，这个操作可以通过信号量来进行操作，但是使得程序变得更加复杂

- 不使用进程，而是使用两个线程

    通过创建两个线程来分别维护两个输入的读取，避免了由于进程间通信带来的复杂性，但是由于需要同步这两个线程，因此在复杂性这一方面不见得会比使用两个进程的方式更好

- 依旧使用一个进程来进行处理，但是使用非阻塞 IO

    将两个输入都变成非阻塞的，对第一个输入发送一个 `read`，如果该输入上有数据，则读取数据并处理它；如果没有数据可读，则直接返回，然后对第二个输入执行类似的操作，在此之后，等待一定的时间，再次执行相同的处理。这种方式被成为 “轮询”，大部分情况下都是无数据可读的，浪费了 CPU 的处理时间，因此应该避免使用

- 还是使用一个进程，但是数据的读取采用异步 IO

    采用异步 IO 的方式来进行处理，每当有准备好的 IO 可以进行时，发送信号通知进程进行处理。这种信号对于每个进程来讲都只有一个，因此当多个 IO 准备好的情况下，无法正确判断到底是那个 IO 准备好了，特别是，能够使用信号量的数量是有限的，因此当文件描述符变多时将会存在问题。

传统的方式都未能很好地处理 `telnet` 存在的问题，IO 多路复用技术可能是解决该问题比较好的一种方案。

IO 多路复用描述如下：首先构造一个文件描述符列表，然后调用一个函数，直到这个列表中至少存在一个 IO 已经准备好的情况下，该函数才返回，在从该函数返回时，进程可以得到已经准备好 IO 的文件描述符号

## 多路复用函数

### select 和 pselect

select：调用 select 函数需要以下几个参数：

- 待检查的 `fd` 集合
- 对于每个 `fd` 我们所关心的操作：读、写以及异常操作
- 希望等待多长时间（可以永远等待、等待一个固定时间或者根本不等待）

调用 select 之后，可以通过 select 得到以下内容：

- 已经准备好的 `fd` 的数量
- 对于读、写或异常这三个条件中的每一个，哪些 `fd` 已经准备好

select 函数的原型如下所示：

```c
#include <sys/select.h>

int select(int nfds, fd_set *readfds, fd_set *writefds,
           fd_set *exceptfds, struct timeval *timeout);
```

函数的最后一个参数  $timeout$ 表示 select 函数愿意等待的时间长度，有以下三种情况：

1. `tvptr == NULL`：表示永远等待，如果捕捉到一个信号则中断此状态
2. `tvptr->tv_sec == 0 && tvptr->tv_usec == 0` ：表示不等待
3. `tvptr->tv_sec != 0 || tvptr->tv_usec != 0` ：表示等待指定的秒数和微秒数

对于中间的三个参数 $readfds$、$writefds$、$exceptfds$ 表示指向 `fd` 集合的指针，具体的状态如下所示：

<img src="https://s2.loli.net/2022/03/24/w8GNBtSRnhCmkDq.png" alt="select.png" style="zoom:80%;" />

具体的集合实现可以不同，这里假设只是一个简单的字节数组。对于 `fd_set` 数据类型，可以通过调用以下几个函数：

```c
#include <sys/select.h>

void FD_CLR(int fd, fd_set *set); // 清除 set 中的某一位 fd
int  FD_ISSET(int fd, fd_set *set); // 如果 fd 在 set 中，返回非 0 值，否则返回 0 值
void FD_SET(int fd, fd_set *set); // 开启 set 中的 fd
void FD_ZERO(fd_set *set); // 将 set 的所有位都设置为 0
```

### poll

### epoll