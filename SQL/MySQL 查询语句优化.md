# MySQL 查询语句优化

## 优化数据访问

查询性能低下最基本的原因是访问的数据太多。特别是有的查询可能不得不筛选大量的数据，但是这种情况不会经常出现。大部分性能低下的查询语句都可以通过减少数据访问量的方式进行优化，一般来讲，通过以下两个方面来分析低效的查询是有效的：

1. 确认应用程序是否在检索大量超过需要的数据，这种情况通常是访问了太多的行，或者访问了太多的列导致的

2. 确认 MySQL 服务器是否在分析大量超过需要的数据行

### 是否请求了不需要的数据

有些查询会请求超过实际需要的数据，然后这些多余的数据会被应用程序丢弃，这其实是不必要的。典型的情况有以下几种：

- 查询不需要的记录
  
  一个常见的错误是常常会误以为 MySQL 只会返回需要的数据，实际上 MySQL 会先返回全部的结果集再进行计算。对于这种情况，在查询的尾部加上 `LIMIT` 子句可能是一个有效的解决方案

- 多表关联时返回全部列
  
  这种情况会返回大量的非必须列，这些列实际上不会被使用，因此查询时需要注意这些，只查询需要的列

- 总是取出全部的列
  
  由于索引的原因，如果总是取出一个表的全部的列可能不得不进行回表查询，因此这可能会降低索引的使用效率。

- 重复查询相同的数据
  
  这种情况一般考虑加入一个缓存中间件来缓存上一次的查询，避免多次的重复查询

### 是否在扫描额外的数据

对于一个 SQL 查询，衡量它的开销主要有以下三个指标：响应时间、扫描的行数、返回的行数。这三个指标都会记录到 MySQL 的慢查询日志中，因此一般检查慢查询日志即可

- 响应时间
  
  响应时间包括两部分时间：服务时间和排队时间。服务时间指的是数据库处理这个查询的时候真正花费了多少时间；排队时间是指服务器因为等待某些资源而没有被真正执行的时间。

- 扫描的行数和返回的行数
  
  理想情况下扫描的行数和返回的行数是一致的，但是这种情况一般不会出现

在评估查询开销的时候，需要考虑一下从表中找到某一行数据的成本。在 MySQL 的 `EXAPLIN` 的 `type` 字段反映了访问类型：全表扫描、范围扫描、唯一索引查询、常数引用等，这里的访问速度从左向右递增。

如果查询没有办法找到合适的访问类型，那么解决的最好办法就是增加一个合适的索引。

在 MySQL 中，如果能够使用如下三种方式来应用 `WHERE` 条件，从好到坏依次为：

- 在索引中应用 `WHERE` 子句中的过滤条件，这些过滤条件可以在索引中完成，而这项任务是在存储引擎层完成的，这样可以最大化提高查询性能

- 使用联合索引来返回记录（在 `Extra` 列中出现了 `using index`），直接从索引中过滤不需要的记录并返回命中的结果，这个操作在 MySQL 的服务层来完成，由于联合索引中存在数据，因此不需要再回表查询

- 从数据表中返回数据，然后过滤不满足条件的记录（在 `Extra` 列中出现 `using where`）。这项操作同样在 MySQL 服务器层实现，MySQL 需要首先从数据表中读取然后再过滤 `WHERE` 条件

如果发现一个查询需要扫描大量的数据但是只是返回少数的行，那么通常可以按照如下的方式优化它：

- 使用联合索引，把需要用到的列都放入到索引中，这样存储引擎就无需回表获取对应的行即可查询到结果

- 改变表的结构，例如使用单独的汇总表

- 重写这个复杂的查询，使得 MySQL 能够以更优化的方式执行这个查询

## 重构查询的方式

在优化有问题的查询时，目标应该是找到一个更优的方法获得实际需要的结果，而不是总是需要从 MySQL 中获取一模一样的结果集。

### 切分查询

有时候将一个大查询分解为多个小查询会是一个很好的选择。比如，在删除旧数据的时候，如果一次性使用大的删除语句进行删除，可能一次需要锁定很多行的数据、阻塞其它查询等；如果将这个删除语句划分为多个较小的查询，可以尽可能地减少对于数据行的影响。

### 分解关联查询

很多高性能的应用都会对关联查询进行分解。简单地，可以对每一个表进行一次单表查询，然后查询结果在应用程序层进行关联（阿里的开发手册就要求禁止三个表以上的关联查询）。

这样做有以下的一些好处：

- 使得缓存的效率更高。很多应用可以方便地缓存单表的查询结果，并且单表查询不需要做额外的笛卡儿积，因此性能更好。

- 将查询分解之后，对于表的影响将会降低。如果是多表查询，那么在查询时可能涉及到锁竞争的问题

- 将关联关系放到应用层，可以提高数据库的可拓展性，对数据库的拆分更加容易

- 可以减少冗余记录的查询。在应用层中做关联查询，意味着对于某条记录应用只需要查询一次，而在数据库中做查询，则可能需要重复地访问一部分数据。

- 更进一步，这样做相当于在应用层中做了哈希关联，而不是使用 MySQL 的嵌套查询关联

## 查询执行的基础

一般来讲，MySQL 执行一个查询时，需要进行如下的流程：

![MySQLpng.png](https://s2.loli.net/2022/04/08/rSIkU8KlAQmvh5s.png)

1. 客户端发送一条查询给服务器

2. 服务器先查询一下缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则，进入下一阶段

3. 服务端进行 SQL 解析、预处理再由优化器生成对应的执行计划

4. MySQL 根据优化器生成的执行计划，调用存储引擎的 API 来执行查询

5. 最终 MySQL 将查询到的结果写入到缓存，同时将结果返回给客户端

#### 查询缓存

在解析一个查询语句之前，如果查询缓存是打开的，那么 MySQL 会优先检查这个缓存是否命中查询缓存中的数据。这个检查是通过对一个大小写敏感的哈希查找来实现的。

#### 查询优化处理

查询的下一个生命周期是将一个 SQL 转换为一个执行计划，MySQL 再按照这个执行计划和存储引擎进行交互。这将包括许多的子阶段：解析 SQL、预处理、优化 SQL 执行计划，在这个过程中的任何错误（例如语法错误）都将终止查询

- 语法解析器和预处理
  
  首先，MySQL 会将关键字将 SQL 语句进行解析，并生成一棵对应的 “解析树”。MySQL 通过解析器将使用 MySQL 语法规则验证和解析。
  
  预处理器则根据一些 MySQL 规则进一步检查解析树是否合法。例如，检查数据表和数据列是否存在，还会解析别名等其它的信息，检查是否存在歧义

- 查询优化器
  
  一条查询可以有很多种执行方式，最后都会返回相同的执行结果。优化器的作用就是在这些可能的查询中，找到最佳的执行计划。
  
  MySQL 使用基于成本的优化器，它将尝试预测一个查询中使用某种执行计划时的成本，并选择其中成本最小的一个。可以通过查询当前会话中的 `last_query_cost` 来查看当前会话中上一次查询的成本：
  
  ```sql
  SHOW STATUS LIKE 'last_query_cost'
  ```
  
  “查询成本” 是指一个查询需要访问多少个最小数据页

##### 关联查询

MySQL 认为任何一次的查询都是一次 “关联”

MySQL 执行 UNION 查询时，首先会将一系列的单个查询结果放入到一个临时表中，然后再读取临时表中的数据来完成 UNION 查询

MySQL 在执行关联查询时，会首先在一个表中循环取出单条数据，然后再嵌套到下一个表中寻找匹配的行，直到找到所有表中匹配的行为止。然后再根据各个表中匹配的行，返回查询中需要地各个列。例如，如下的查询语句：

```sql
SELECT 
    tb1.col1, tb2.col2 
FROM 
    tb1 
INNER JOIN 
    tb2 USING(col3) 
WHERE 
    tb1.col1 IN (5, 6)
```

按照 MySQL 的执行顺序，可以转换为对应的伪代码执行顺序：

```js
outer_iter = iterator over tb1 where col1 IN(5, 6)
outer_row = outer_iter.next
while outer_row:
    inner_iter = iterator over tb2 where col3=outer_row.col3
    inner_row = inner_iter.next
    while inner_row
        output [outer_row.col1, inner_row.col2]
        inner_row = inner_iter.next
    end
    outer_row = outer_iter.next
end
```

MySQL 对所有类型的查询都以同样的方式进行处理，例如，MySQL 在 `FROM` 子句中遇到**子查询**时，先执行**子查询**并将其结果放入到一个临时表中（MySQL 的临时表不存在索引，这一点对于 `UNION` 查询也一样），然后将这个临时表当做是一个普通表对待。

一般情况下，MySQL 在执行关联查询时，会自动优化关联表的连接顺序，这种情况下一般是最优的。如果认为自己的关联会比 MySQL 优化后的关联会更好，可以通过在关联时使用 `STRAIGHT_JOIN` 来进行表的连接，但是这通常是不必要的。

MySQL 的关联优化器会尝试在所有的关联顺序中选择一个成本最小的来生成执行计划树，如果可以的话，MySQL 会遍历每一种可能来计算相关的成本，然后选择最优的关联顺序。但是这在某些情况下是不太可能发生的，比如，假设有 $n$ 个表做关联，那么需要检查 $n!$ 种关联顺序，当 $n$ 很大时，这种方式带来的收益远小于成本。为了提供尽可能的优化，MySQL 会以 “贪心” 的策略找到近似最优的关联顺序。可以通过指定 `optimizer_search_depth` 来指定这个阈值

##### 排序优化

如果对相关的列创建了联合索引，那么按照联合索引的最左匹配原则进行列的排序则不需要进行额外的排序。

大多数情况下，表中不存在这样的联合索引，并且排序的顺序也未必能够按照预期的设想进行排序。因此不得不对查询到的数据进行额外的排序，这一类排序也被称为 “文件排序”（不管数据是否在内存中）

如果需要排序的数据量小于 “排序缓冲区”，MySQL 将使用内存进行 “快速排序” 操作。如果内存不足，则需要将数据进行分块处理，将每个数据块放入到内存中进行排序，最后合并每个数据块

MySQL 中存在以下两种排序算法：

- 两次传输排序（旧版本）
  
  读取指针和需要排序的字段，对其进行排序，然后再按照排序的结果读取需要的数据。这需要进行两次数据读取，第一次读取页信息，第二次从页对应的数据块中读取数据，因此性能不是特别好

- 单次传输排序
  
  将要排序的数据读入到内存中，按照给定的列进行排序，最后返回排序的结果。

这两种算法各有优缺点，可以通过设置 `max_length_for_sort_data` 属性来设置阈值来自动选择排序算法（小于这个阈值选择 “单次传输排序”）

如果在关联的时候需要进行排序，MySQL 会分两种情况来处理这样的文件排序：

- 如果 `ORDER BY` 子句中所有的列都来自关联的第一个表，那么 MySQL 在关联处理第一个表的时候就会进行文件排序。在这种情况下，使用 `EXAPLAIN` 查看执行计划时在 `Extra` 字段中会存在 `Using filesort`

- 其余的情况，MySQL 会将关联的结果放入到一个临时表中，然后在所有的关联结束之后，再进行文件排序。在这种情况下，使用 `EXPLAIN` 查看执行计划可以在 `Extra` 字段中看到 "Using temporary; Usgin filesort"。如果此时包含 `LIMIT` 子句的话，会在排序之后在取记录，因此即使只是需要少量的数据，临时表依旧可能很大

#### 查询优化器的局限性

MySQL 查询优化器在以下几种查询中存在一些局限性：

##### 关联子查询

MySQL 的子查询的实现不是特别特别优秀，最糟糕的情况是在 `WHERE` 子句中包含 `IN` 的子查询。例如，对于下面的 `SQL` 语句：

```sql
SELECT * 
FROM 
    salaries 
WHERE 
    emp_no IN (
        SELECT emp_no 
        FROM 
            employees 
        WHERE
            birth_date BETWEEN '1960-01-01' AND '1962-01-01'
    );
```

实际上，MySQL 会将外层表压入到子查询中，将该查询等价地转换为如下的 `SQL` ：

```sql
SELECT *
FROM
    salaries
WHERE
    EXISTS (
        SELECT emp_no
        FROM
            employees
        WHERE
            birth_date BETWEEN '1960-01-01' AND '1962-01-01'
            AND salaries.emp_no=employees.emp_no
    );
```

通过 `EXAPLIN` 查看，如下图所示：

![image.png](https://s2.loli.net/2022/04/11/ra1qzNfUniRel7b.png)

可以看到，查询时首先会对 `employee` 表进行一次全表查询。为了解决这个问题，可以通过直接连接的方式进行查询而不是通过子查询的方式，如下所示：

```sql
SELECT 
    salaries.*
FROM
     salaries
JOIN employees ON salaries.emp_no = employees.emp_no
WHERE 
    employees.birth_date BETWEEN '1960-01-01' AND '1962-01-01'
```

- UNION 查询
  
  如果希望 UNION 的各个子句能够根据 `LIMIT` 子句只取部分的结果集合，或者希望能够先进行排序在合并结果集合，那么就需要在 UNION 的各个子句中分别使用这些子句。
  
  在 MySQL 8.0 中此项优化无效

## 优化特定查询

### 优化 `COUNT()` 函数

`COUNT()` 函数是一个特殊的函数，一般情况下有两种使用场景：统计某个列值的记录数、单纯地统计记录数。默认在统计时统计非 NULL 值的记录数，但是如果在函数中指定了对应的表达式，则统计的就是这个表达式的结果

### 优化关联查询

- 确保 `ON` 或者 `USING` 子句中的列上有索引。在创建索引时需要考虑到关联顺序，当表 A 和表 B 通过 c 列来进行关联时，如果优化器的的关联顺序是 B —> A，那么就不需要在 表 B 上创建对应的索引

- 确保任何的 `GROUP BY` 和 `ORDER BY` 中的表达式只涉及到一个表中的列，这种情况下 MySQL 才有可能使用索引来优化这个过程

### 优化 GROUP BY 和 DISTINCT

在 MySQL 中，当无法使用索引的时候，`GROUP BY` 子句使用两种策略来完成：使用临时表或者文件排序来做分组。这两种策略的性能都存在提升的空间

可以通过使用 `SQL_BIG_RESULT` 和 `SQL_SMALL_RESULT` 来让优化器按照预期的方式运行，这在某些情况下可能有效

在对关联查询执行 `GROUP BY` 子句时，将 `GROUP BY` 对应的列设置为标识列（id列）会比其它的列有更好的性能；此外，尽量使用记录数比较少的表，这样能够尽可能地加快 `GROUP BY` 的执行速度

如果没有通过 `ORDER BY` 子句指定排序列，那么当查询使用 `GROUP BY` 子句时，结果集合会按照自动分组的字段进行排序。如果不关心结果集的顺序，可以通过加上 `ORDER BY NULL` 子句来禁止排序

### 优化 LIMIT

当系统中需要执行分页操作时，通常会通过使用 `LIMIT` 子句加上对应的偏移量来实现，一般情况下还会加上 `ORDER BY` 子句。在存在索引的情况下，效率通常是很可观的。

当表中的记录数特别多、`LIMIT` 子句的偏移量特别大的时候，如 `LIMIT 1000, 10`，这一类的语句，实际上前 $1000$ 条记录都是无用的。对于这一类语句的优化，只能通过两个角度进行优化：限制分页的数量、优化大偏移量的性能

如果是通过优化大偏移量的角度进行优化，一个最简单的方式就是使用联合索引来覆盖这些列，然后再通过一次关联查询返回需要的列。例如，对于下面的查询：

```sql
-- describeption 列不在联合索引上，但是 title 有自己的索引
SELECT film_id, description FROM film ORDER BY title LIMIT 50, 5;
```

那么，可以考虑将其转换为如下的查询：

```sql
SELECT 
    film.film_id, film.description
FROM 
    film
INNER JOIN (
    SELECT film_id
    FROM film
    ORDER BY title
    LIMIT 50, 5
) AS c ON c.film_id = film.film_id;
```

这样就可以尽可能地利用索引来优化 `LIMIT` 子句

如果可能，可以考虑使用 `BETWEEN ... AND ...` 来替换 `LIMIT` 子句可能是一个不错的选择。

如果是对于分页的情况，那么在查询时多查询一条数据是一个可选的优化方案，通过这条多余的数据，然后使用 `WHERE` 子句来代替 `OFFSET` 将是一个可以考虑的选择

### 优化 UNION

MySQL 对于 `UNION` 子句的执行是通过创建并填充临时表的方式来实现的，由于临时表本身不具备索引，因此许多的优化策略在 `UNION` 子句中可能是无效的。

一般情况下，对于 `UNION` 子句的优化都是通过将 `WHERE`、`LIMIT`、`GROUP BY` 等子句放入子查询中，使得子查询处理这些子句，便能够得到较好的优化。

除非需求确实确定需要消除重复的行，否则一定要选择 `UNION ALL` 而不是 `UNION`。
