# MySQL 高性能索引策略

## 独立的列

对于已经创建了索引的列，如果查询时的列结构不是独立的，比如：包含计算，那么这种情况下对于该列的查询就无法使用索引。

例如，以下的 `SQL` 语句：

```sql
SELECT user_name FROM user_info WHERE user_id + 1 < 5
```

无论如何都无法使用到 `user_id` 的索引，因为 `MySQL` 对于这种查询只能通过全表扫描检查是否满足条件来进行检索，这种情况也被称为 “非独立列查找”，为了解决这个问题，需要将 `user_id` 作为独立的搜索条件，如下所示：

```sql
SELECT user_name FROM user_info WHERE user_id < 4
```

## 前缀索引和索引选择性

如果待索引的列未一个很长的字符串，比如 `URL`，那么这种情况下单独对这些列建立索引效果可能不是特别好。一般的解决方案是将这些列通过对应的 `Hash` 函数转换为相关的 $64$ 位整数，将生成的整数作为单独的列再建立索引，一般情况下能够解决索引过大过慢的问题

在某些情况下，只是 `Hash` 转换可能还不够，此时可以考虑只索引字符串的一部分前缀字符，从而提高索引的效率。这样做的缺点是会降低索引的选择性。

> 索引的选择性：不重复的索引值（基数）和数据表的记录总数（$T$）的比值

索引的选择性越高，那么对应的查询效率将会越高，因此选择性高的索引可以使得 MySQL 在查找时能够过滤更多的行。

一般情况下，足够长的字符串前缀足以保证较高的选择性，能够满足查询性能。特别是，对于特别长的列（如 `BLOB`、`TEXT` 等），MySQL 不允许索引这些列的全部长度，只能使用前缀索引

使用前缀索引无法进行 `GROUP BY` 和 `ORDER BY` 操作，也无法使用其做覆盖扫描（因为它不是精确的）




