# MySQL 高性能索引策略

## 独立的列

对于已经创建了索引的列，如果查询时的列结构不是独立的，比如：包含计算，那么这种情况下对于该列的查询就无法使用索引。

例如，以下的 `SQL` 语句：

```sql
SELECT user_name FROM user_info WHERE user_id + 1 < 5
```

无论如何都无法使用到 `user_id` 的索引，因为 `MySQL` 对于这种查询只能通过全表扫描检查是否满足条件来进行检索，这种情况也被称为 “非独立列查找”，为了解决这个问题，需要将 `user_id` 作为独立的搜索条件，如下所示：

```sql
SELECT user_name FROM user_info WHERE user_id < 4
```

## 前缀索引和索引选择性

如果待索引的列未一个很长的字符串，比如 `URL`，那么这种情况下单独对这些列建立索引效果可能不是特别好。一般的解决方案是将这些列通过对应的 `Hash` 函数转换为相关的 $64$ 位整数，将生成的整数作为单独的列再建立索引，一般情况下能够解决索引过大过慢的问题

在某些情况下，只是 `Hash` 转换可能还不够，此时可以考虑只索引字符串的一部分前缀字符，从而提高索引的效率。这样做的缺点是会降低索引的选择性。

> 索引的选择性：不重复的索引值（基数）和数据表的记录总数（$T$）的比值

索引的选择性越高，那么对应的查询效率将会越高，因此选择性高的索引可以使得 MySQL 在查找时能够过滤更多的行。

一般情况下，足够长的字符串前缀足以保证较高的选择性，能够满足查询性能。特别是，对于特别长的列（如 `BLOB`、`TEXT` 等），MySQL 不允许索引这些列的全部长度，只能使用前缀索引

使用前缀索引无法进行 `GROUP BY` 和 `ORDER BY` 操作，也无法使用其做覆盖扫描（因为它不是精确的）

## 合适的索引顺序

在一个多列的 `B-Tree` 索引中，索引列的顺序意味着索引首先按照最左列进行排序，其次是第二列、第三列…………，所以索引的创建顺序至关重要。

对于如何选择索引的列顺序有一个经验法则：将 “索引选择性” 最高的列放在前面通常是一个比较好的策略。这种方式在大多数情况下都是有效的，但是这也取决于具体执行的查询语句以及值的分布有关，具体需要在实际使用中进行特别的考虑（没有银弹）

## 使用索引扫描来进行排序

MySQL 有两种方式来生成有序的结果：一是通过对结果进行排序；二是按照索引顺序扫描。如果通过 `EXAPLIAN` 命令出来的 `type` 列的值为 `index`，则说明 MySQL 使用了索引扫描来对结果进行排序。

如果索引能够覆盖到查询所需要的全部列，那么这种排序查找时比较快速的。但是如果查询不能覆盖查询所需的全部的列，那么就不得不扫描一条索引记录就回表查询一次对应的记录，回表操作会降低查询的效率。因此如果可以的话，尽量按照要排序的查询建立对应的联合索引

只有当索引的列顺序完全和 `ORDER BY` 子句的顺序一致、并且此时列的排列方向完全一致时（正序或倒序），MySQL 才能够使用索引对结果进行排序；如果查询时需要关联多张表，则只有当 `ORDER BY` 子句引用的字段全部为第一个表时，才能使用索引做排序

`ORDER BY` 子句和查询时存在的限制类似，二者都要求满足索引的最左前缀（按照联合索引的顺序），否则，将无法利用索引。但是 `ORDER BY` 子句存在一种特殊情况：当前导列为常量时，即使用 `WHERE` 或者 `JOIN` 子句对这些列使用了常量，可以弥补这个问题

如，对于下面创建的表 `rental` :

```sql
CREATE TABLE rental (
    …………
    PRIMARY KEY(rental_id),
    UNIQUE KEY rental_date_key (rental_date, inventory_id, customer_id)
)
```

如果此时执行如下的 `SQL` 语句，依旧可以使用索引执行 `ORDER BY` 子句：

```sql
SELECT rental_id, staff_id 
FROM 
    rental 
WHERE 
    rental_date='2022-01-01'
ORDER BY
    inventory_id, customer_id
```








