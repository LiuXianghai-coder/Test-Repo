# Redis 集群

## 集群的引入

传统的 `Redis` 集群是基于 “主从复制” + “哨兵” 来实现的，这种方式的缺点在于整个集群只能有一个 `Master` 节点用于提供写服务。

自 `Redis 3.0` 开始，引入了去中心化的分片集群 `Redis Cluster`。`Redis Cluster` 采用多主多从的方式，支持开启多个主节点，每个主节点上可以挂载多个从节点。

`Cluster` 会将数据进行分片，将数据分散到多个主节点上，而每个主节点都能够对外提供读写服务。这种方式使得 `Redis` 突破了单机内存的限制，扩展了集群的存储容量。

`Redis Cluster` 是一个去中心化的集群，每个节点都会和其它节点保持连接，使用 `gossip` 协议来交换彼此的信息，以及探测新加入的节点信息。`Redis Cluster` 无需任何代理，客户端会直接和集群中的节点相连接



## 集群的分片方式

主要有以下几种分片方式：

- 哈希取摸

    在处理请求之前对该请求进行 `hash` 操作，经过该项操作之后会得到该请求对应的 `hashCode`，然后将该 `hashCode` 对集群的容量进行求模操作，确定最终处理该请求的 `Redis` 节点。

    如果这个 `hash` 操作足够优秀，理论上来讲能够将请求均匀地分散到每个节点。

    但是问题很明显，如果需要对 `Redis` 节点进行扩容或者收缩，那么求模操作的结果将会变得不可靠，因此一般情况下不会采用这种分片方式

- 一致性哈希

    由于 “哈希求模” 方式存在的缺陷，因此引入了 “一致性哈希” 的算法来进行进一步的处理。

    “一致性哈希” 会将所有的哈希值组成一个虚拟的圆环，如下图所示：

    <img src="https://s2.loli.net/2022/02/26/pnHzxe9DJiOPdfw.png" alt="image.png" style="zoom:67%;" />

    算法的具体步骤：

    - 首先针对请求进行 `hash` 操作，确定当前请求在环上的位置
    - 从确定的位置开始，顺时针查找，直到找到第一个能够处理该请求的实例节点

    当新增或者删除实例节点时，就不会出现找不到实例节点的问题。

    <br />

    “一致性哈希” 算法解决了 “哈希取模” 中存在的问题，但是它也有缺陷：

    当节点很少时，增加或者删除实例节点对单个节点的影响会很大，从而导致不能均匀地处理请求的情况。以上图为例，如果移除了 `node4` 节点，那么将会有很大一部分的请求都会交给 `node3` 节点进行处理而无法做到均衡的处理请求，可能最终导致系统的崩溃。这个问题也被称为 “哈希偏环” 问题

- 虚拟节点 + 一致性哈希

    为了解决一致性哈希中存在的问题，引入 “虚拟节点” 的概念进行进一步的处理，如下图所示：

    <img src="https://s2.loli.net/2022/02/26/SZWB73X4avcxtlK.png" alt="image.png" style="zoom:67%;" />

    引入虚拟节点之后，请求到实例节点的处理的映射关系就变成了由虚拟节点来进行处理，这样能够很大程度上解决 “哈希偏环” 的问题

    **注意：** 这种方式并不会完全解决 “哈希偏环” 问题，而且由于虚拟节点的引入，会增加系统的复杂性。在实际应用中，“一致性哈希” 这种算法很难处理巨大的高负载，因此这种情况下就不会使用 “一致性哈希”

## Redis 集群的部署

可以参考官方的文档：https://redis.io/topics/cluster-tutorial

<br />

参考：

<sup>[1]</sup> https://mp.weixin.qq.com/s/bs5NfSkQlFbFp7KMQ9aLmw

<sup>[2]</sup> https://hihcys.github.io/2020/03/17/%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%8E%AF%E5%8F%8A%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/

<sup>[3]</sup> https://redis.io/topics/cluster-tutorial