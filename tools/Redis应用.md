# `Redis` 应用

## 分布式锁

- 使用 `Redis` 实现分布式锁

  - `RedLock` 算法

    > 1. 获取当前时间戳，单位是毫秒
    > 2. 尝试顺序地获取 N 个实例中的锁，在所有的实例中使用相同的键名和随机值。当在每个实例中设置锁的时候，客户端使用与主节点锁自动释放时间相比较小的超时时间来获取它。例如，如果自动释放锁的时间是 10s，那么超时时间可以在 5~50 毫秒的时间范围内。这样可以防止客户端长时间处于阻塞状态。如果试图与已经宕机的 `Redis` 节点通信，我们应该尝试与下一个实例通信。
    > 3. 尝试在大多数节点上设置这个锁，大多数要求大于 n/2 的节点数，此时认为该锁已经被获取。
    > 4. 如果获取锁失败了，那么将会尝试释放所有的锁

  - `Redission`

    > 一个开源的高性能 Redis 客户端框架

    实现细节：

    1. `Redission` 的所有指令都是通过 `lua` 脚本来执行，`Redis` 支持 `lua` 脚本原子性地执行
    2. `Redission` 设置一个 `key`  的默认过期时间为 30s。通过 `WatchDog`每隔一定的时间重新设置过期时间。这样可以避免当前持有的锁过期问题
    3. `Redission` 的 `WatchDog` 逻辑保证不会发生死锁

- 使用 `Zookeeper` 实现分布式锁

  - `Zookerrper` 模型：`Zookeeper` 包含一系列的节点，称之为 `znode`，`znode` 类似u于一个文件目录。

    `Znode` 的特性：

    1. 有序节点：假设当前有一个父节点为 `/lock`，那么可以在这个父节点下面创建子节点；`Zookeeper` 提供了一个可选的有序特性，例如如果我们创建子节点 “/lock/node-” 并指明有序，那么 `Zookeeper` 在生成子节点时会根据当前节点的子数量自动添加整数序号
    2. 临时节点：客户端可以建立一个临时节点，在会话结束或者会话超时之后，`Zookeeper` 会自动删除该节点
    3. 时间监听：在读取数据时，可以同时对节点设置事件监听，当节点数据或结构发生变化时，`Zookeeper` 会自动通知客户端。当前的 `Zookeeper` 存在以下几种事件：
       - 节点创建
       - 节点删除
       - 节点数据修改
       - 字节点变更

  - `Zookeeper` 实现的分布式锁

    1. 使用 `Zookeeper` 下的临时节点和有序节点，每个线程获取锁就是在 `Zookeeper` 创建一个临时的有序节点。
    2. 创建节点成功之后，获取对应目录下的所有临时节点，在判断当前创建的节点是否是所有节点中序号最小的节点。
    3. 如果当前创建的节点是所有获取到的临时节点中序号最小的节点，那么则认为获取锁成功
    4. 如果当前创建的节点不是所有获取到的临时节点中序号最小的节点，则对前一个序号的节点添加一个事件监听。如果前一个节点的锁释放了，则会唤醒下一个序号的节点，然后重新执行第三步。

  - `Curator`是一个开源的 `Zookeeper` 客户端工具，也提供了分布式锁的实现



## 消息队列

> 不常用，比如 `RabbitMQ`、`Kafka` 等更好

- `BLPOP`
- `BRPOP`

发布者、订阅者： https://redis.io/topics/pubsub

> `SUBSCRIBE`、`UNSUBSCRIBE` 和 `PUBLISH` 实现了 “发布/订阅” 范式。其中，发送者（发布者）不是编程化地发送消息到指定的接受这（订阅者），而是发布的消息被表示为一个 Channel，发布者不知道有哪些可能存在的订阅者。订阅者只对一个或者更多的 Channel 感兴趣。订阅者只是接收它感兴趣的的消息，而不知道是哪个发布者发布了它。发布者和消费者之间的解藕可以允许更大的缩放和更加动态的网络拓扑。
>
> 例如，订阅者想要订阅 `foo` 和 `bar` 的 Channel，客户端发出 `SUBSCRIBE` 命令来订阅这两个 Channel。
>
> ```bash
> SUBSCRIBE foo bar
> ```
>
> 其它客户端发送的消息都会发送到这几个 Channel，然后 `Redis` 会推送到所有的订阅者客户端。
>
> 一个已经订阅了一个或者多个 Channel 的客户端不应该发送命令，尽管它可以可以从其他 Channel 那里订阅或者取消订阅。订阅和取消订阅的操作以消息的形式发送，这样客户端就可以读取连贯的消息流，其中，第一个元素表示消息的类型。以下这些命令在订阅者客户端中是被允许的：`SUBSCRIBE`、`PSUBSCRIBE`、`UNSUBSCRIBE`、`PUNSUBSCRIBE`、`PING`、`QUIT`。
>
> 请注意， 一旦订阅者模式开启了，那么 `redis-cli` 将不会再接受任何命令，退出订阅者模式的唯一方法是使用 `Ctrl + C`
>
> 
>
> #### 发布的消息的格式
>
> - 一个消息是一个有三个元素的 `Array Reply`
>
> - 第一个元素是消息的种类
>   - subscribe：表示我们成功地订阅到了 Channel 的消息，第二个元素就是消息的内容。第三个参数代表我们当前订阅的 Channel 号
>   - unsubscribe：表示我们成功取消了在 Channel 上的订阅，第二个元素作为消息的返回内容，第三个参数代表我们当前订阅的 Channel 号。当最后一个参数为 0 时，我们不在有任何 Channel 的订阅，此时客户端可以输入任意的 `Redis` 命令（因为此时我们处于 “发布/订阅”状态之外）
>   - message：这是一条由于其他客户端使用 `PULISH` 命令而收到的消息；第二个参数表示订阅到的消息的初始 Channel 名；第三个参数表示实际的消息载荷。
>
> 
>
> #### 数据库 & 范围界定
>
> “发布者/订阅者” 和 `key` 空间没有关系，它不会在任何级别上造成干扰，包括数据库编号。
>
> 如果你需要一些种类的范围界定，可以使 Channel 的名称带上对应的环境名称（test、staging、production）
>
> 
>
> #### 模式匹配订阅
>
> `Redis` 的 “发布/订阅” 实现支持模式匹配，客户端可能订阅全局匹配的模式，去接收所有和给定模式匹配的 Channel 上的所有消息。
>
> 例如：
>
> ```bash
> PSUBSCRIBE news.*
> ```
>
> 将会接收所有发送到 Channel 名类似 news.art、news.figure 等 Channel 上的所有消息。所有的全局通配符都是有效的，因此多个通配符也是被支持的。
>
> ```bash
> PUNSUBSCRIBE news.*
> ```
>
> 以上命令将会取消 Channel 名和 new.* 匹配的所有 Channel。这个调用不会影响其它的订阅者。
>
> 由于模式匹配而收到的消息以不同的格式发送。
>
> - 这种类型的消息是 `pmessage`：它是被其它客户端输入 `PULISH` 命令的结果接收到的消息，匹配一个模式匹配的订阅者；第二个元素是匹配的原始模式；第三个元素是初始的 Channel 名；最后一个元素是实际的消息载荷
>
> 与 SUBSCRIBE 和 UNSUBSCRIBE 类似，PSUBSCRIBE 和 PUNSUBSCRIBE 命令由系统使用与订阅和取消订阅消息格式相同的格式发送 psubscribe 和 punsubscribe 类型的消息来确认。
>
> 
>
> #### 匹配模式和频道订阅的消息
>
> 如果客户端订阅了多个与已发布消息匹配的模式，或者订阅了与该消息匹配的模式和通道，则该客户端可能会多次收到一条消息。
>
> ```bash
> SUBSCRIBE foo
> PSUBSCRIBE f*
> ```
>
> 在以上实例中，如果消息被发送到 `foo` Channel，那么这个客户端将会收到两次消息：一次是 `message` 类型的消息；一次是 `pmessage` 的消息
>
> 
>
> #### 模式匹配订阅计数的含义
>
> 在 subscribe、unsubscribe、psubscribe 和 punsubscribe 消息类型中，最后一个参数是仍处于活动状态的订阅数。 这个数字实际上是客户端仍然订阅的频道和模式的总数。 因此，只有当由于取消订阅所有频道和模式而导致此计数下降到零时，客户端才会退出 Pub/Sub 状态。



## 位图

> 使用一个比特位来表示某个元素的状态，由于一个 bit 位只表示 0 和 1 两种状态，因此能够节省大量的空间。

在 Redis 中，`BitMap` 是通过 `String` 来实现的。

使用场景：

- 用户签到
- 统计活跃用户
- 验证用户是否在线
- 实现布隆过滤器